# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `byebug-dap` gem.
# Please instead update this file by running `bin/tapioca gem byebug-dap`.


# source://byebug-dap//lib/byebug/gem.rb#1
module Byebug
  extend ::Byebug::Helpers::ReflectionHelper

  # source://byebug/11.1.3/lib/byebug/core.rb#31
  def displays; end

  # source://byebug/11.1.3/lib/byebug/core.rb#31
  def displays=(_arg0); end

  # source://byebug/11.1.3/lib/byebug/core.rb#25
  def init_file; end

  # source://byebug/11.1.3/lib/byebug/core.rb#25
  def init_file=(_arg0); end

  # source://byebug/11.1.3/lib/byebug/core.rb#41
  def mode; end

  # source://byebug/11.1.3/lib/byebug/core.rb#41
  def mode=(_arg0); end

  # source://byebug/11.1.3/lib/byebug/core.rb#52
  def run_init_script; end

  private

  def add_catchpoint(_arg0); end
  def breakpoints; end
  def catchpoints; end
  def contexts; end
  def current_context; end
  def debug_load(*_arg0); end
  def lock; end
  def post_mortem=(_arg0); end
  def post_mortem?; end
  def raised_exception; end

  # source://byebug/11.1.3/lib/byebug/core.rb#102
  def rc_dirs; end

  # source://byebug/11.1.3/lib/byebug/core.rb#91
  def run_rc_file(rc_file); end

  def start; end
  def started?; end
  def stop; end
  def stoppable?; end
  def thread_context(_arg0); end
  def tracing=(_arg0); end
  def tracing?; end
  def unlock; end
  def verbose=(_arg0); end
  def verbose?; end

  class << self
    # source://byebug/11.1.3/lib/byebug/remote.rb#25
    def actual_control_port; end

    # source://byebug/11.1.3/lib/byebug/remote.rb#20
    def actual_port; end

    def add_catchpoint(_arg0); end

    # source://byebug/11.1.3/lib/byebug/attacher.rb#10
    def attach; end

    def breakpoints; end
    def catchpoints; end
    def contexts; end
    def current_context; end
    def debug_load(*_arg0); end

    # source://byebug/11.1.3/lib/byebug/core.rb#76
    def handle_post_mortem; end

    # source://byebug/11.1.3/lib/byebug/remote.rb#32
    def interrupt; end

    # source://byebug/11.1.3/lib/byebug/core.rb#61
    def load_settings; end

    def lock; end

    # source://byebug/11.1.3/lib/byebug/remote.rb#59
    def parse_host_and_port(host_port_spec); end

    def post_mortem=(_arg0); end
    def post_mortem?; end
    def raised_exception; end

    # source://byebug/11.1.3/lib/byebug/attacher.rb#21
    def spawn(host = T.unsafe(nil), port = T.unsafe(nil)); end

    def start; end

    # source://byebug/11.1.3/lib/byebug/remote.rb#55
    def start_client(host = T.unsafe(nil), port = T.unsafe(nil)); end

    # source://byebug/11.1.3/lib/byebug/remote.rb#48
    def start_control(host = T.unsafe(nil), port = T.unsafe(nil)); end

    # Creates and starts the server. See {DAP::Server#initialize} and
    # {DAP::Server#start}.
    #
    # @param host the host passed to {DAP::Server#start}
    # @param port the port passed to {DAP::Server#start}
    # @return [DAP::Server]
    #
    # source://byebug-dap//lib/byebug/dap.rb#35
    def start_dap(host, port = T.unsafe(nil)); end

    # source://byebug/11.1.3/lib/byebug/remote.rb#39
    def start_server(host = T.unsafe(nil), port = T.unsafe(nil)); end

    def started?; end
    def stop; end
    def stoppable?; end
    def thread_context(_arg0); end
    def tracing=(_arg0); end
    def tracing?; end
    def unlock; end
    def verbose=(_arg0); end
    def verbose?; end

    # source://byebug/11.1.3/lib/byebug/remote.rb#17
    def wait_connection; end

    # source://byebug/11.1.3/lib/byebug/remote.rb#17
    def wait_connection=(_arg0); end

    private

    # source://byebug/11.1.3/lib/byebug/remote.rb#66
    def client; end

    # source://byebug/11.1.3/lib/byebug/remote.rb#76
    def control; end

    # source://byebug/11.1.3/lib/byebug/remote.rb#70
    def server; end
  end
end

# source://byebug-dap//lib/byebug/dap.rb#40
class Byebug::Context
  extend ::Byebug::Helpers::PathHelper

  # source://byebug/11.1.3/lib/byebug/context.rb#113
  def at_breakpoint(breakpoint); end

  # source://byebug/11.1.3/lib/byebug/context.rb#120
  def at_catchpoint(exception); end

  # source://byebug/11.1.3/lib/byebug/context.rb#136
  def at_end; end

  # source://byebug/11.1.3/lib/byebug/context.rb#94
  def at_line; end

  # source://byebug/11.1.3/lib/byebug/context.rb#127
  def at_return(return_value); end

  # source://byebug/11.1.3/lib/byebug/context.rb#104
  def at_tracing; end

  def backtrace; end
  def dead?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def file(*args, **_arg1, &block); end

  # source://byebug/11.1.3/lib/byebug/context.rb#46
  def frame; end

  # source://byebug/11.1.3/lib/byebug/context.rb#53
  def frame=(pos); end

  def frame_binding(*_arg0); end
  def frame_class(*_arg0); end
  def frame_file(*_arg0); end
  def frame_line(*_arg0); end
  def frame_method(*_arg0); end
  def frame_self(*_arg0); end

  # source://byebug/11.1.3/lib/byebug/context.rb#70
  def full_location; end

  def ignored?; end

  # source://byebug/11.1.3/lib/byebug/context.rb#87
  def interrupt; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def line(*args, **_arg1, &block); end

  # source://byebug/11.1.3/lib/byebug/context.rb#63
  def location; end

  # source://byebug/11.1.3/lib/byebug/context.rb#144
  def processor; end

  def resume; end

  # source://byebug/11.1.3/lib/byebug/context.rb#79
  def stack_size; end

  def step_into(*_arg0); end
  def step_out(*_arg0); end
  def step_over(*_arg0); end
  def stop_reason; end
  def suspend; end
  def suspended?; end
  def switch; end
  def thnum; end
  def thread; end
  def tracing; end
  def tracing=(_arg0); end

  private

  # source://byebug/11.1.3/lib/byebug/context.rb#153
  def ignored_file?(path); end

  class << self
    # source://byebug/11.1.3/lib/byebug/context.rb#25
    def ignored_files; end

    # source://byebug/11.1.3/lib/byebug/context.rb#20
    def ignored_files=(_arg0); end

    # source://byebug/11.1.3/lib/byebug/context.rb#32
    def interface; end

    # source://byebug/11.1.3/lib/byebug/context.rb#30
    def interface=(_arg0); end

    # source://byebug/11.1.3/lib/byebug/context.rb#38
    def processor; end

    # source://byebug/11.1.3/lib/byebug/context.rb#36
    def processor=(_arg0); end
  end
end

# Debug Adapter Protocol support for Byebug
#
# source://byebug-dap//lib/byebug/gem.rb#3
module Byebug::DAP
  class << self
    # Record a {ChildSpawnedEventBody childSpawned event} and send the event
    # to the current session's client, if
    # {gem:byebug:Byebug::Context.interface} is a {Session}.
    #
    # source://byebug-dap//lib/byebug/dap.rb#57
    def child_spawned(*args); end

    # Call {Session#stop!} on {gem:byebug:Byebug::Context.interface} if it is
    # a {Session}.
    #
    # @return [Boolean] whether {gem:byebug:Byebug::Context.interface} was a {Session}
    #
    # source://byebug-dap//lib/byebug/dap.rb#52
    def stop!; end
  end
end

# Gem authors
#
# source://byebug-dap//lib/byebug/gem.rb#17
Byebug::DAP::AUTHORS = T.let(T.unsafe(nil), Array)

# Captures STDOUT and STDERR. See {CapturedOutput}.
#
# @api private
#
# source://byebug-dap//lib/byebug/dap/helpers/captured_io.rb#4
class Byebug::DAP::CapturedIO
  # Capture STDOUT and STDERR and create a new
  # {gem:byebug:Byebug::DebugThread} running {#capture}. See
  # {CapturedOutput#initialize}.
  #
  # @api private
  # @param forward_stdout [Boolean] if true, captured STDOUT is forwarded to the original STDOUT.
  # @param forward_stderr [Boolean] if true, captured STDERR is forwarded to the original STDERR.
  # @return [CapturedIO] a new instance of CapturedIO
  #
  # source://byebug-dap//lib/byebug/dap/helpers/captured_io.rb#10
  def initialize(forward_stdout, forward_stderr); end

  # Return an IO that can be used for logging.
  #
  # @api private
  # @return [std:IO]
  #
  # source://byebug-dap//lib/byebug/dap/helpers/captured_io.rb#22
  def log; end

  # {CapturedOutput#restore Restore} the original STDOUT and STDERR.
  #
  # @api private
  #
  # source://byebug-dap//lib/byebug/dap/helpers/captured_io.rb#33
  def restore; end

  private

  # In a loop, read from the captured STDOUT and STDERR and send an output
  # event to the active session's client (if there is an active session), and
  # optionally forward the output to the original STDOUT/STDERR.
  #
  # @api private
  #
  # source://byebug-dap//lib/byebug/dap/helpers/captured_io.rb#46
  def capture; end

  # @api private
  #
  # source://byebug-dap//lib/byebug/dap/helpers/captured_io.rb#70
  def send(source, data); end
end

# Captures an IO output stream.
#
# @api private
#
# source://byebug-dap//lib/byebug/dap/helpers/captured_output.rb#4
class Byebug::DAP::CapturedOutput
  # Capture `io`, {std:IO#dup duplicate} the original, open an {std:IO.pipe
  # pipe} pair, and {std:IO#reopen reopen} `io` to redirect it to the pipe.
  #
  # @api private
  # @return [CapturedOutput] a new instance of CapturedOutput
  #
  # source://byebug-dap//lib/byebug/dap/helpers/captured_output.rb#16
  def initialize(io); end

  # The captured stream. Captured output can be read from this IO.
  #
  # @api private
  # @return [std:IO]
  #
  # source://byebug-dap//lib/byebug/dap/helpers/captured_output.rb#12
  def captured; end

  # The original stream, {std:IO#dup duplicated} from `io`. Writing to this IO
  # will write to the original file.
  #
  # @api private
  # @return [std:IO]
  #
  # source://byebug-dap//lib/byebug/dap/helpers/captured_output.rb#8
  def original; end

  # Restore `io` to the original file.
  #
  # @api private
  #
  # source://byebug-dap//lib/byebug/dap/helpers/captured_output.rb#26
  def restore; end
end

# A channel for synchronously passing values between threads.
#
# @api private
#
# source://byebug-dap//lib/byebug/dap/helpers/channel.rb#5
class Byebug::DAP::Channel
  # @api private
  # @return [Channel] a new instance of Channel
  #
  # source://byebug-dap//lib/byebug/dap/helpers/channel.rb#6
  def initialize; end

  # Close the channel.
  #
  # @api private
  #
  # source://byebug-dap//lib/byebug/dap/helpers/channel.rb#14
  def close; end

  # Pop an item off the channel. Blocks until {#push} or {#close} is called.
  #
  # @api private
  # @return a value that was pushed or `nil` if the channel is closed.
  #
  # source://byebug-dap//lib/byebug/dap/helpers/channel.rb#23
  def pop; end

  # Push an item onto the channel. Raises an error if the channel is closed.
  # If `timeout` is nil, blocks until {#push} or {#close} is called.
  #
  # @api private
  # @param message the value to push
  # @yield called on timeout
  #
  # source://byebug-dap//lib/byebug/dap/helpers/channel.rb#41
  def push(message, timeout: T.unsafe(nil)); end

  private

  # @api private
  #
  # source://byebug-dap//lib/byebug/dap/helpers/channel.rb#68
  def synchronize_loop; end
end

# `childSpawned` is a custom DAP event used to notify the client that a
# child process has spawned.
#
# @api private
#
# source://byebug-dap//lib/byebug/dap/helpers/child_spawned_event_body.rb#6
class Byebug::DAP::ChildSpawnedEventBody < ::DAP::Base
  # The child process's name
  #
  # @return [std:String]
  #
  # source://ruby-dap/0.1.3/lib/dap/base.rb#93
  def name; end

  # The child's process ID
  #
  # @return [std:Integer]
  #
  # source://ruby-dap/0.1.3/lib/dap/base.rb#93
  def pid; end

  # The debug socket to connect to
  #
  # @return [std:String]
  #
  # source://ruby-dap/0.1.3/lib/dap/base.rb#93
  def socket; end
end

# Implementation of a DAP command.
#
# @abstract Subclasses must implement {#execute}
#
# source://byebug-dap//lib/byebug/dap/command.rb#4
class Byebug::DAP::Command
  include ::Byebug::DAP::SafeHelpers

  # Create a new instance of the receiver.
  #
  # @param session [Session] the debug session
  # @param request [Protocol::Request] the DAP request
  # @return [Command] a new instance of Command
  #
  # source://byebug-dap//lib/byebug/dap/command.rb#55
  def initialize(session, request); end

  # Write a message to the log.
  #
  # source://byebug-dap//lib/byebug/dap/command.rb#61
  def log(*args); end

  # Call {#execute} safely, handling any errors that arise.
  #
  # @return the return value of {#execute}
  #
  # source://byebug-dap//lib/byebug/dap/command.rb#67
  def safe_execute; end

  private

  # source://byebug-dap//lib/byebug/dap/command.rb#135
  def args; end

  # source://byebug-dap//lib/byebug/dap/command.rb#220
  def can_read_file!(path); end

  # source://byebug-dap//lib/byebug/dap/command.rb#239
  def convert_breakpoint_condition(condition); end

  # @raise [InvalidRequestArgumentError]
  #
  # source://byebug-dap//lib/byebug/dap/command.rb#245
  def convert_breakpoint_hit_condition(condition); end

  # source://byebug-dap//lib/byebug/dap/command.rb#105
  def event!(*args, **values); end

  # source://byebug-dap//lib/byebug/dap/command.rb#139
  def exception_description(ex); end

  # Execute a code block on the specified thread, {SafeHelpers#safe safely}.
  #
  # @api private
  # @param thnum [std:Integer] the thread number
  # @param block [std:Proc] the code block
  # @yield called on error
  # @yieldparam ex [std:Exception] the execution error
  #
  # source://byebug-dap//lib/byebug/dap/command.rb#150
  def execute_on_thread(thnum, block, &on_error); end

  # @raise [InvalidRequestArgumentError]
  #
  # source://byebug-dap//lib/byebug/dap/command.rb#166
  def find_frame(ctx, frnum); end

  # source://byebug-dap//lib/byebug/dap/command.rb#273
  def find_or_add_breakpoint(verified, existing, source, pos); end

  # @raise [InvalidRequestArgumentError]
  #
  # source://byebug-dap//lib/byebug/dap/command.rb#157
  def find_thread(thnum); end

  # source://byebug-dap//lib/byebug/dap/command.rb#233
  def potential_breakpoint_lines(path); end

  # @raise [InvalidRequestArgumentError]
  #
  # source://byebug-dap//lib/byebug/dap/command.rb#172
  def resolve_frame_id(id); end

  # @raise [InvalidRequestArgumentError]
  #
  # source://byebug-dap//lib/byebug/dap/command.rb#184
  def resolve_variables_reference(ref); end

  # source://byebug-dap//lib/byebug/dap/command.rb#110
  def respond!(*args, **values); end

  # Raises an error unless the debugger is running
  #
  # @api private
  #
  # source://byebug-dap//lib/byebug/dap/command.rb#129
  def started!; end

  # Raises an error if the debugger is running
  #
  # @api private
  #
  # source://byebug-dap//lib/byebug/dap/command.rb#120
  def stopped!; end

  class << self
    # The DAP command assocated with the receiver.
    #
    # @return [std:String]
    #
    # source://byebug-dap//lib/byebug/dap/command.rb#12
    def command; end

    # Resolve and execute the requested command. The command is {.resolve!
    # resolved}, {#initialize initialized}, and {#safe_execute safely executed}.
    #
    # @param session [Session] the debug session
    # @param request [Protocol::Request] the DAP request
    # @param args [std:Array] additional arguments for {#initialize}
    # @return the return value of {#safe_execute}
    #
    # source://byebug-dap//lib/byebug/dap/command.rb#46
    def execute(session, request, *args); end

    # Register the receiver as a DAP command.
    #
    # source://byebug-dap//lib/byebug/dap/command.rb#24
    def register!; end

    # Resolve the requested command. Calls {Session#respond!} indicating a
    # failed request if the command cannot be found.
    #
    # @param session [Session] the debug session
    # @param request [Protocol::Request] the DAP request
    # @return [std:Class] the {Command} class
    #
    # source://byebug-dap//lib/byebug/dap/command.rb#33
    def resolve!(session, request); end
  end
end

# source://byebug-dap//lib/byebug/dap/commands/attach.rb#2
class Byebug::DAP::Command::Attach < ::Byebug::DAP::Command
  # source://byebug-dap//lib/byebug/dap/commands/attach.rb#7
  def execute; end
end

# source://byebug-dap//lib/byebug/dap/commands/breakpoint_locations.rb#2
class Byebug::DAP::Command::BreakpointLocations < ::Byebug::DAP::Command
  # source://byebug-dap//lib/byebug/dap/commands/breakpoint_locations.rb#7
  def execute; end
end

# source://byebug-dap//lib/byebug/dap/commands/configuration_done.rb#2
class Byebug::DAP::Command::ConfigurationDone < ::Byebug::DAP::Command
  # source://byebug-dap//lib/byebug/dap/commands/configuration_done.rb#7
  def execute; end
end

# source://byebug-dap//lib/byebug/dap/commands/continue.rb#2
class Byebug::DAP::Command::Continue < ::Byebug::DAP::ContextualCommand
  # source://byebug-dap//lib/byebug/dap/commands/continue.rb#7
  def execute_in_context; end

  private

  # source://byebug-dap//lib/byebug/dap/commands/continue.rb#13
  def forward_to_context(ctx); end
end

# source://byebug-dap//lib/byebug/dap/commands/disconnect.rb#2
class Byebug::DAP::Command::Disconnect < ::Byebug::DAP::Command
  # source://byebug-dap//lib/byebug/dap/commands/disconnect.rb#11
  def execute; end
end

# The error message returned when a variable or expression cannot be evaluated.
#
# source://byebug-dap//lib/byebug/dap/command.rb#6
Byebug::DAP::Command::EVAL_ERROR = T.let(T.unsafe(nil), String)

# source://byebug-dap//lib/byebug/dap/commands/evaluate.rb#2
class Byebug::DAP::Command::Evaluate < ::Byebug::DAP::Command
  include ::Byebug::DAP::ValueHelpers

  # source://byebug-dap//lib/byebug/dap/commands/evaluate.rb#10
  def execute; end

  private

  # source://byebug-dap//lib/byebug/dap/commands/evaluate.rb#18
  def evaluate; end
end

# source://byebug-dap//lib/byebug/dap/commands/exception_info.rb#2
class Byebug::DAP::Command::ExceptionInfo < ::Byebug::DAP::ContextualCommand
  # source://byebug-dap//lib/byebug/dap/commands/exception_info.rb#7
  def execute_in_context; end

  private

  # source://byebug-dap//lib/byebug/dap/commands/exception_info.rb#25
  def details(ex, eval_name); end
end

# source://byebug-dap//lib/byebug/dap/commands/initialize.rb#2
class Byebug::DAP::Command::Initialize < ::Byebug::DAP::Command
  # source://byebug-dap//lib/byebug/dap/commands/initialize.rb#11
  def execute; end
end

# source://byebug-dap//lib/byebug/dap/commands/launch.rb#2
class Byebug::DAP::Command::Launch < ::Byebug::DAP::Command
  # source://byebug-dap//lib/byebug/dap/commands/launch.rb#7
  def execute; end
end

# source://byebug-dap//lib/byebug/dap/commands/next.rb#2
class Byebug::DAP::Command::Next < ::Byebug::DAP::ContextualCommand
  # source://byebug-dap//lib/byebug/dap/commands/next.rb#8
  def execute_in_context; end

  private

  # source://byebug-dap//lib/byebug/dap/commands/next.rb#15
  def forward_to_context(ctx); end
end

# source://byebug-dap//lib/byebug/dap/commands/pause.rb#2
class Byebug::DAP::Command::Pause < ::Byebug::DAP::ContextualCommand
  # source://byebug-dap//lib/byebug/dap/commands/pause.rb#8
  def execute_in_context; end

  private

  # source://byebug-dap//lib/byebug/dap/commands/pause.rb#14
  def forward_to_context(ctx); end
end

# source://byebug-dap//lib/byebug/dap/commands/scopes.rb#2
class Byebug::DAP::Command::Scopes < ::Byebug::DAP::Command
  # source://byebug-dap//lib/byebug/dap/commands/scopes.rb#7
  def execute; end

  private

  # source://byebug-dap//lib/byebug/dap/commands/scopes.rb#44
  def frame_local_names(frame); end

  # source://byebug-dap//lib/byebug/dap/commands/scopes.rb#52
  def global_names; end
end

# source://byebug-dap//lib/byebug/dap/commands/set_breakpoints.rb#2
class Byebug::DAP::Command::SetBreakpoints < ::Byebug::DAP::Command
  # source://byebug-dap//lib/byebug/dap/commands/set_breakpoints.rb#9
  def execute; end
end

# source://byebug-dap//lib/byebug/dap/commands/set_exception_breakpoints.rb#2
class Byebug::DAP::Command::SetExceptionBreakpoints < ::Byebug::DAP::Command
  # source://byebug-dap//lib/byebug/dap/commands/set_exception_breakpoints.rb#15
  def execute; end
end

# "The request configures the debuggers response to thrown exceptions.
# "If an exception is configured to break, a ‘stopped’ event is fired (with reason ‘exception’).
#
# source://byebug-dap//lib/byebug/dap/commands/set_exception_breakpoints.rb#6
Byebug::DAP::Command::SetExceptionBreakpoints::FILTERS = T.let(T.unsafe(nil), Array)

# source://byebug-dap//lib/byebug/dap/commands/set_function_breakpoints.rb#2
class Byebug::DAP::Command::SetFunctionBreakpoints < ::Byebug::DAP::Command
  # source://byebug-dap//lib/byebug/dap/commands/set_function_breakpoints.rb#9
  def execute; end

  private

  # source://byebug-dap//lib/byebug/dap/commands/set_function_breakpoints.rb#67
  def resolve_method(class_name, method_name); end
end

# source://byebug-dap//lib/byebug/dap/commands/source.rb#2
class Byebug::DAP::Command::Source < ::Byebug::DAP::Command
  # source://byebug-dap//lib/byebug/dap/commands/source.rb#7
  def execute; end
end

# source://byebug-dap//lib/byebug/dap/commands/stack_trace.rb#2
class Byebug::DAP::Command::StackTrace < ::Byebug::DAP::Command
  # source://byebug-dap//lib/byebug/dap/commands/stack_trace.rb#7
  def execute; end

  private

  # source://byebug-dap//lib/byebug/dap/commands/stack_trace.rb#44
  def frame_name(frame); end
end

# source://byebug-dap//lib/byebug/dap/commands/step_in.rb#2
class Byebug::DAP::Command::StepIn < ::Byebug::DAP::ContextualCommand
  # source://byebug-dap//lib/byebug/dap/commands/step_in.rb#12
  def execute_in_context; end

  private

  # source://byebug-dap//lib/byebug/dap/commands/step_in.rb#19
  def forward_to_context(ctx); end
end

# source://byebug-dap//lib/byebug/dap/commands/step_out.rb#2
class Byebug::DAP::Command::StepOut < ::Byebug::DAP::ContextualCommand
  # source://byebug-dap//lib/byebug/dap/commands/step_out.rb#8
  def execute_in_context; end

  private

  # source://byebug-dap//lib/byebug/dap/commands/step_out.rb#16
  def forward_to_context(ctx); end
end

# source://byebug-dap//lib/byebug/dap/commands/threads.rb#2
class Byebug::DAP::Command::Threads < ::Byebug::DAP::Command
  # source://byebug-dap//lib/byebug/dap/commands/threads.rb#7
  def execute; end
end

# source://byebug-dap//lib/byebug/dap/commands/variables.rb#2
class Byebug::DAP::Command::Variables < ::Byebug::DAP::Command
  include ::Byebug::DAP::ValueHelpers

  # source://byebug-dap//lib/byebug/dap/commands/variables.rb#10
  def execute; end
end

# Processes thread-specific commands and handles Byebug/TracePoint events.
#
# source://byebug-dap//lib/byebug/dap/command_processor.rb#4
class Byebug::DAP::CommandProcessor
  include ::Byebug::DAP::SafeHelpers
  extend ::Forwardable

  # Create a new command processor.
  #
  # @api private
  # @note This should only be used by Byebug internals
  # @param context [gem:byebug:Byebug::Context] the thread context
  # @param session [Session] the debugging session
  # @return [CommandProcessor] a new instance of CommandProcessor
  #
  # source://byebug-dap//lib/byebug/dap/command_processor.rb#38
  def initialize(context, session); end

  # Send a message to the thread context.
  #
  # @note Raises a {TimeoutError timeout error} after 1 second if the thread is not paused or not responding.
  # @param message the message to send
  #
  # source://byebug-dap//lib/byebug/dap/command_processor.rb#54
  def <<(message); end

  # Breakpoint handler.
  #
  # @api private
  # @note This should only be called by Byebug internals
  #
  # source://byebug-dap//lib/byebug/dap/command_processor.rb#109
  def at_breakpoint(breakpoint); end

  # Catchpoint handler.
  #
  # @api private
  # @note This should only be called by Byebug internals
  #
  # source://byebug-dap//lib/byebug/dap/command_processor.rb#116
  def at_catchpoint(exception); end

  # End of class/module handler.
  #
  # @api private
  # @note This should only be called by Byebug internals
  #
  # source://byebug-dap//lib/byebug/dap/command_processor.rb#87
  def at_end; end

  # Line handler.
  #
  # @api private
  # @note This should only be called by Byebug internals
  #
  # source://byebug-dap//lib/byebug/dap/command_processor.rb#80
  def at_line; end

  # Return handler.
  #
  # @api private
  # @note This should only be called by Byebug internals
  #
  # source://byebug-dap//lib/byebug/dap/command_processor.rb#94
  def at_return(return_value); end

  # Tracing handler.
  #
  # @api private
  # @note This should only be called by Byebug internals
  #
  # source://byebug-dap//lib/byebug/dap/command_processor.rb#102
  def at_tracing; end

  # The thread context.
  #
  # @return [gem:byebug:Byebug::Context]
  #
  # source://byebug-dap//lib/byebug/dap/command_processor.rb#21
  def context; end

  # Execute a code block in the thread.
  #
  # @note This calls {#\<\<} and thus may raise a {TimeoutError timeout error}.
  # @yield the code block to execute
  #
  # source://byebug-dap//lib/byebug/dap/command_processor.rb#61
  def execute(&block); end

  # The last exception that occured.
  #
  # @return [std:Exception]
  #
  # source://byebug-dap//lib/byebug/dap/command_processor.rb#25
  def last_exception; end

  # Write a message to the log.
  #
  # source://byebug-dap//lib/byebug/dap/command_processor.rb#47
  def log(*args); end

  # Indicates that the client requested a pause.
  #
  # @api private
  # @note This should only be set by {Command::Pause}
  # @return [Boolean]
  #
  # source://byebug-dap//lib/byebug/dap/command_processor.rb#31
  def pause_requested=(_arg0); end

  private

  # source://byebug-dap//lib/byebug/dap/command_processor.rb#187
  def logpoint!; end

  # source://byebug-dap//lib/byebug/dap/command_processor.rb#122
  def process_requests; end

  # source://byebug-dap//lib/byebug/dap/command_processor.rb#144
  def stopped!; end
end

# Indicates a timeout while sending a message to the context.
#
# source://byebug-dap//lib/byebug/dap/command_processor.rb#9
class Byebug::DAP::CommandProcessor::TimeoutError < ::StandardError
  # @return [TimeoutError] a new instance of TimeoutError
  #
  # source://byebug-dap//lib/byebug/dap/command_processor.rb#14
  def initialize(context); end

  # The receiving context.
  #
  # @return [gem:byebug:Byebug::Context]
  #
  # source://byebug-dap//lib/byebug/dap/command_processor.rb#12
  def context; end
end

# Implementation of a DAP command that must be executed in-context.
#
# @abstract Subclasses must implement {#execute_in_context}
#
# source://byebug-dap//lib/byebug/dap/contextual_command.rb#4
class Byebug::DAP::ContextualCommand < ::Byebug::DAP::Command
  # Create a new instance of the receiver.
  #
  # @param session [Session] the debug session
  # @param request [Protocol::Request] the DAP request
  # @param processor [CommandProcessor] the command processor associated with the context
  # @return [ContextualCommand] a new instance of ContextualCommand
  #
  # source://byebug-dap//lib/byebug/dap/contextual_command.rb#18
  def initialize(session, request, processor = T.unsafe(nil)); end

  # {#execute_in_context Execute in-context} if `processor` is defined.
  # Otherwise, ensure debugging is {#started! started}, find the requested
  # thread context, and {#forward_to_context forward the request}.
  #
  # source://byebug-dap//lib/byebug/dap/contextual_command.rb#27
  def execute; end

  private

  # Forward the request to the context's thread.
  #
  # @api private
  # @param ctx [gem:byebug:Byebug::Context] the context
  #
  # source://byebug-dap//lib/byebug/dap/contextual_command.rb#41
  def forward_to_context(ctx); end

  class << self
    # Resolve the requested command. Calls {Session#respond!} indicating a
    # failed request if the command cannot be found.
    #
    # @note Raises an error if the resolved class is not a subclass of {ContextualCommand}
    # @param session [Session] the debug session
    # @param request [Protocol::Request] the DAP request
    # @return [std:Class] the {Command} class
    #
    # source://byebug-dap//lib/byebug/dap/contextual_command.rb#7
    def resolve!(session, request); end
  end
end

# Gem description
#
# source://byebug-dap//lib/byebug/gem.rb#14
Byebug::DAP::DESCRIPTION = T.let(T.unsafe(nil), String)

# Debug logging
#
# source://byebug-dap//lib/byebug/dap.rb#64
module Byebug::DAP::Debug
  class << self
    # Log evaluation failures.
    #
    # @return [Boolean]
    #
    # source://byebug-dap//lib/byebug/dap.rb#75
    def evaluate; end

    # Log evaluation failures.
    #
    # @return [Boolean]
    #
    # source://byebug-dap//lib/byebug/dap.rb#75
    def evaluate=(_arg0); end

    # Log all sent and received protocol messages.
    #
    # @return [Boolean]
    #
    # source://byebug-dap//lib/byebug/dap.rb#71
    def protocol; end

    # Log all sent and received protocol messages.
    #
    # @return [Boolean]
    #
    # source://byebug-dap//lib/byebug/dap.rb#71
    def protocol=(_arg0); end
  end
end

# Tracks opaque handles used by DAP.
#
# @api private
#
# source://byebug-dap//lib/byebug/dap/helpers/handles.rb#5
class Byebug::DAP::Handles
  # @api private
  # @return [Handles] a new instance of Handles
  #
  # source://byebug-dap//lib/byebug/dap/helpers/handles.rb#6
  def initialize; end

  # Add a new entry.
  #
  # @api private
  # @return [std:Integer] the handle
  #
  # source://byebug-dap//lib/byebug/dap/helpers/handles.rb#25
  def <<(entry); end

  # Retrieve the entry with the specified handle.
  #
  # @api private
  # @param id [std:Integer] the handle
  # @return the entry
  #
  # source://byebug-dap//lib/byebug/dap/helpers/handles.rb#19
  def [](id); end

  # Delete all handles.
  #
  # @api private
  #
  # source://byebug-dap//lib/byebug/dap/helpers/handles.rb#12
  def clear!; end

  private

  # @api private
  #
  # source://byebug-dap//lib/byebug/dap/helpers/handles.rb#34
  def sync; end
end

# Raised when the client sends a request with invalid arguments
#
# @api private
#
# source://byebug-dap//lib/byebug/dap/helpers/invalid_request_argument_error.rb#5
class Byebug::DAP::InvalidRequestArgumentError < ::StandardError
  # @api private
  # @return [InvalidRequestArgumentError] a new instance of InvalidRequestArgumentError
  #
  # source://byebug-dap//lib/byebug/dap/helpers/invalid_request_argument_error.rb#16
  def initialize(error, value: T.unsafe(nil), scope: T.unsafe(nil)); end

  # The error kind or message.
  #
  # @api private
  # @return [std:Symbol|std:String]
  #
  # source://byebug-dap//lib/byebug/dap/helpers/invalid_request_argument_error.rb#8
  def error; end

  # The error scope.
  #
  # @api private
  #
  # source://byebug-dap//lib/byebug/dap/helpers/invalid_request_argument_error.rb#14
  def scope; end

  # The error value.
  #
  # @api private
  #
  # source://byebug-dap//lib/byebug/dap/helpers/invalid_request_argument_error.rb#11
  def value; end
end

# source://byebug-dap//lib/byebug/gem.rb#23
Byebug::DAP::LICENSE = T.let(T.unsafe(nil), String)

# Gem name
#
# source://byebug-dap//lib/byebug/gem.rb#5
Byebug::DAP::NAME = T.let(T.unsafe(nil), String)

# An alias for `ruby-dap`'s {DAP} module.
#
# source://byebug-dap//lib/byebug/dap.rb#10
Byebug::DAP::Protocol = DAP

# A debug session 'connection' using STDIN and STDOUT.
#
# @api private
#
# source://byebug-dap//lib/byebug/dap/helpers/stdio.rb#4
class Byebug::DAP::STDIO
  extend ::Forwardable

  # @api private
  # @return [STDIO] a new instance of STDIO
  #
  # source://byebug-dap//lib/byebug/dap/helpers/stdio.rb#7
  def initialize; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def <<(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def bytes(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def chars(*args, **_arg1, &block); end

  # @api private
  #
  # source://byebug-dap//lib/byebug/dap/helpers/stdio.rb#14
  def close; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close_read(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close_write(*args, **_arg1, &block); end

  # @api private
  # @return [Boolean]
  #
  # source://byebug-dap//lib/byebug/dap/helpers/stdio.rb#17
  def closed?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def codepoints(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each_byte(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each_char(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each_codepoint(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each_line(*args, **_arg1, &block); end

  # @api private
  #
  # source://byebug-dap//lib/byebug/dap/helpers/stdio.rb#15
  def flush; end

  # @api private
  #
  # source://byebug-dap//lib/byebug/dap/helpers/stdio.rb#16
  def fsync; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def getbyte(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def getc(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def gets(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def lines(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def pread(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def print(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def printf(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def putc(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def puts(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def pwrite(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def read(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def read_nonblock(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def readbyte(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def readchar(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def readline(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def readlines(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def readpartial(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def sysread(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def syswrite(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def ungetbyte(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def ungetc(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def write(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def write_nonblock(*args, **_arg1, &block); end
end

# Gem summary
#
# source://byebug-dap//lib/byebug/gem.rb#11
Byebug::DAP::SUMMARY = T.let(T.unsafe(nil), String)

# Methods to safely execute methods.
#
# @api private
#
# source://byebug-dap//lib/byebug/dap/helpers/safe_helpers.rb#5
module Byebug::DAP::SafeHelpers
  # Safely execute `method` on `target` with `args`.
  #
  # @api private
  # @param target the receiver
  # @param method [std:Symbol] the method name
  # @param args [std:Array] the method arguments
  # @yield called on error
  # @yieldparam ex [std:StandardError] the execution error
  #
  # source://byebug-dap//lib/byebug/dap/helpers/safe_helpers.rb#12
  def safe(target, method, *args, &block); end
end

# Used in case statements to identify scalar types.
#
# @api private
#
# source://byebug-dap//lib/byebug/dap/helpers/scalar.rb#4
module Byebug::DAP::Scalar
  # Match scalar values. {std:NilClass nil}, {std:TrueClass true},
  # {std:FalseClass false}, {std:String strings}, {std:Numeric numbers},
  # {std:Time times}, {std:Range ranges}, {std:date:Date dates}, and
  # {std:date:DateTime date-times} are considered scalars.
  #
  # @api private
  # @return [Boolean]
  #
  # source://byebug-dap//lib/byebug/dap/helpers/scalar.rb#10
  def ===(value); end
end

# Byebug DAP Server
#
# source://byebug-dap//lib/byebug/dap/server.rb#4
class Byebug::DAP::Server
  # Create a new server.
  #
  # @param capture [Boolean] if `true`, the debugee's STDOUT and STDERR will be captured
  # @param forward [Boolean] if `false`, the debugee's STDOUT and STDERR will be supressed
  # @return [Server] a new instance of Server
  #
  # source://byebug-dap//lib/byebug/dap/server.rb#8
  def initialize(capture: T.unsafe(nil), forward: T.unsafe(nil)); end

  # Starts the server. Calls {#start_stdio} if `host == :stdio`. Calls
  # {#start_unix} with `port` if `host == :unix`. Calls {#start_tcp} with
  # `host` and `port` otherwise.
  #
  # @param host `:stdio`, `:unix`, or the TCP host name
  # @param port the Unix socket path or TCP port
  # @return [Server]
  #
  # source://byebug-dap//lib/byebug/dap/server.rb#23
  def start(host, port = T.unsafe(nil)); end

  # Starts the server using STDIN and STDOUT to communicate.
  #
  # @return [Server]
  #
  # source://byebug-dap//lib/byebug/dap/server.rb#59
  def start_stdio; end

  # Starts the server, listening on a TCP socket.
  #
  # @param host [std:String] the IP to listen on
  # @param port [std:Number] the port to listen on
  # @return [Server]
  #
  # source://byebug-dap//lib/byebug/dap/server.rb#38
  def start_tcp(host, port); end

  # Starts the server, listening on a Unix socket.
  #
  # @param socket [std:String] the Unix socket path
  # @return [Server]
  #
  # source://byebug-dap//lib/byebug/dap/server.rb#49
  def start_unix(socket); end

  # Blocks until a client connects and begins debugging.
  #
  # source://byebug-dap//lib/byebug/dap/server.rb#70
  def wait_for_client; end

  private

  # source://byebug-dap//lib/byebug/dap/server.rb#116
  def debug(connection); end

  # source://byebug-dap//lib/byebug/dap/server.rb#92
  def launch(stream); end

  # source://byebug-dap//lib/byebug/dap/server.rb#103
  def launch_accept(server); end

  # source://byebug-dap//lib/byebug/dap/server.rb#82
  def log; end
end

# A Byebug DAP session
#
# source://byebug-dap//lib/byebug/dap/session.rb#4
class Byebug::DAP::Session
  include ::Byebug::DAP::SafeHelpers

  # Create a new session instance.
  #
  # @param connection [std:IO] the connection to the client
  # @param ios [CapturedIO] the captured IO
  # @return [Session] a new instance of Session
  # @yield called once the client is done configuring the session (optional)
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#39
  def initialize(connection, ios = T.unsafe(nil), &block); end

  # Delete the specified breakpoints and any log points associated with
  # them.
  #
  # @param breakpoints [std:Array<gem:byebug:Byebug::Breakpoint>] the breakpoints
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#191
  def clear_breakpoints(*breakpoints); end

  # Call the block passed to {#initialize}.
  #
  # @api private
  # @note This should only be used by the {Command::ConfigurationDone configurationDone} commands
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#97
  def configured!; end

  # Send an event to the client. Either call with an event name and body
  # attributes, or call with an already constructed body.
  #
  # @param event [std:String|Protocol::Base] the event name or event body
  # @param values [std:Hash] event body attributes
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#119
  def event!(event, **values); end

  # Execute requests from the client until the connection is closed.
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#66
  def execute; end

  # Get the log point expression associated with `breakpoint`.
  #
  # @api private
  # @note This should only be used by a {CommandProcessor command processor}
  # @param breakpoint [gem:byebug:Byebug::Breakpoint] the breakpoint
  # @return [std:String] the log point expression
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#171
  def get_log_point(breakpoint); end

  # Invalidate frame IDs and variables references.
  #
  # @api private
  # @note This should only be used by a {ContextualCommand contextual command} that un-pauses its context
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#78
  def invalidate_handles!; end

  # Write a message to the log.
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#53
  def log(*args); end

  # Send a response to the client.
  #
  # @param request [Protocol::Request] the request to respond to
  # @param body [std:Hash|Protocol::Base] the response body
  # @param success [std:Boolean] whether the request was successful
  # @param message [std:String] the response message
  # @param values [std:Hash] additional response attributes
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#136
  def respond!(request, body = T.unsafe(nil), success: T.unsafe(nil), message: T.unsafe(nil), **values); end

  # Restore a frame from an ID.
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#162
  def restore_frame(id); end

  # Retrieve variables from a reference.
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#152
  def restore_variables(ref); end

  # Create a frame ID.
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#157
  def save_frame(*args); end

  # Create a variables reference.
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#147
  def save_variables(*args); end

  # Associate a log point expression with `breakpoint`.
  #
  # @api private
  # @note This should only be used by a {CommandProcessor command processor}
  # @param breakpoint [gem:byebug:Byebug::Breakpoint] the breakpoint
  # @param expr [std:String] the log point expression
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#180
  def set_log_point(breakpoint, expr); end

  # Start Byebug.
  #
  # @api private
  # @note This should only be used by the {Command::Attach attach} or {Command::Launch launch} commands
  # @param mode [std:Symbol] `:attached` or `:launched`
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#87
  def start!(mode); end

  # Stop Byebug and close the client's connection.
  #
  # @note If the session was started with the `launch` command, this will {std:Kernel#exit exit}
  #
  # source://byebug-dap//lib/byebug/dap/session.rb#106
  def stop!; end

  private

  # source://byebug-dap//lib/byebug/dap/session.rb#200
  def notify_of_children; end

  # source://byebug-dap//lib/byebug/dap/session.rb#218
  def process_trace(trace); end

  # source://byebug-dap//lib/byebug/dap/session.rb#212
  def receive; end

  # source://byebug-dap//lib/byebug/dap/session.rb#206
  def send(message); end

  class << self
    # Record a {ChildSpawnedEventBody childSpawned event} and send the event
    # to the current session's client, if
    # {gem:byebug:Byebug::Context.interface} is a {Session}.
    #
    # source://byebug-dap//lib/byebug/dap/session.rb#21
    def child_spawned(name, pid, socket); end

    # Call {Session#stop!} on {gem:byebug:Byebug::Context.interface} if it is
    # a {Session}.
    #
    # @return [Boolean] whether {gem:byebug:Byebug::Context.interface} was a {Session}
    #
    # source://byebug-dap//lib/byebug/dap/session.rb#10
    def stop!; end
  end
end

# Gem version
#
# source://byebug-dap//lib/byebug/gem.rb#8
Byebug::DAP::VERSION = T.let(T.unsafe(nil), String)

# Methods to prepare values for DAP responses.
#
# @api private
#
# source://byebug-dap//lib/byebug/dap/helpers/value_helpers.rb#4
module Byebug::DAP::ValueHelpers
  # Safely inspect a value and retrieve its class name, class and instance
  # variables, and indexed members. {Scalar} values do not have variables or
  # members. Only {std:Array arrays} and {std:Hash hashes} have members.
  #
  # @api private
  # @return `val.inspect`, `val.class.name`, variables, and members.
  #
  # source://byebug-dap//lib/byebug/dap/helpers/value_helpers.rb#9
  def prepare_value(val); end

  # Prepare a {Protocol::Variable} or {Protocol::EvaluateResponseBody} for a
  # calculated value. For global variables and evaluations, `thnum` and
  # `frnum` should be 0. Local variables and evaluations are
  # {Command#execute_on_thread executed on the specified thread}.
  #
  # @api private
  # @param thnum [std:Integer] the thread number
  # @param frnum [std:Integer] the frame number
  # @param kind [std:Symbol] `:variable` or `:evaluate`
  # @param name [std:String] the variable name (ignored for evaluations)
  # @yield retrieves an variable or evaluates an expression
  #
  # source://byebug-dap//lib/byebug/dap/helpers/value_helpers.rb#39
  def prepare_value_response(thnum, frnum, kind, name: T.unsafe(nil), &block); end
end

# Gem website
#
# source://byebug-dap//lib/byebug/gem.rb#20
Byebug::DAP::WEBSITE = T.let(T.unsafe(nil), String)

class Byebug::DebugThread < ::Thread
  class << self
    def inherited; end
  end
end

# source://byebug-dap//lib/byebug/dap.rb#44
class Byebug::Frame
  # source://byebug/11.1.3/lib/byebug/frame.rb#14
  def initialize(context, pos); end

  # source://byebug/11.1.3/lib/byebug/frame.rb#31
  def _binding; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#35
  def _class; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#39
  def _method; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#27
  def _self; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#62
  def args; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#141
  def c_frame?; end

  # Returns the value of attribute context.
  #
  # source://byebug-dap//lib/byebug/dap.rb#45
  def context; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#43
  def current?; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#89
  def deco_args; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#76
  def deco_block; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#106
  def deco_call; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#72
  def deco_class; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#113
  def deco_file; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#80
  def deco_method; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#120
  def deco_pos; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#19
  def file; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#23
  def line; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#50
  def locals; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#131
  def mark; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#12
  def pos; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#145
  def to_hash; end

  private

  # source://byebug/11.1.3/lib/byebug/frame.rb#158
  def c_args; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#178
  def prefix_and_default(arg_type); end

  # source://byebug/11.1.3/lib/byebug/frame.rb#164
  def ruby_args; end

  # source://byebug/11.1.3/lib/byebug/frame.rb#174
  def use_short_style?(arg); end
end

class Byebug::ThreadsTable; end
