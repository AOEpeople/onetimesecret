# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `gibbler` gem.
# Please instead update this file by running `bin/tapioca gem gibbler`.


# source://gibbler//lib/gibbler/mixins.rb#33
module Addressable; end

# source://gibbler//lib/gibbler/mixins.rb#33
class Addressable::URI
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::String
  extend ::Attic

  # source://addressable/2.8.6/lib/addressable/uri.rb#830
  def initialize(options = T.unsafe(nil)); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1889
  def +(uri); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2239
  def ==(uri); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2217
  def ===(uri); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1879
  def absolute?; end

  # source://attic/1.0.1/lib/attic.rb#156
  def all_instance_variables; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1234
  def authority; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1274
  def authority=(new_authority); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1588
  def basename; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1454
  def default_port; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2396
  def defer_validation; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2201
  def display_uri; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1225
  def domain; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2271
  def dup; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2333
  def empty?; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2406
  def encode_with(coder); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2253
  def eql?(uri); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1598
  def extname; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1810
  def fragment; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1835
  def fragment=(new_fragment); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#870
  def freeze; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2263
  def hash; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1120
  def host; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1156
  def host=(new_host); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1178
  def hostname; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1190
  def hostname=(new_hostname); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1440
  def inferred_port; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2417
  def init_with(coder); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2384
  def inspect; end

  # source://attic/1.0.1/lib/attic.rb#151
  def instance_variables; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1855
  def ip_based?; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1889
  def join(uri); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1992
  def join!(uri); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2007
  def merge(hash); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2072
  def merge!(uri); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2164
  def normalize; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2190
  def normalize!; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1252
  def normalized_authority; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1816
  def normalized_fragment; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1126
  def normalized_host; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1002
  def normalized_password; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1535
  def normalized_path; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1392
  def normalized_port; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1613
  def normalized_query(*flags); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#896
  def normalized_scheme; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1485
  def normalized_site; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#947
  def normalized_user; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1068
  def normalized_userinfo; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2297
  def omit(*components); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2324
  def omit!(*components); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1314
  def origin; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1333
  def origin=(new_origin); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#996
  def password; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1025
  def password=(new_password); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1528
  def path; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1567
  def path=(new_path); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1386
  def port; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1408
  def port=(new_port); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1607
  def query; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1641
  def query=(new_query); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1672
  def query_values(return_type = T.unsafe(nil)); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1723
  def query_values=(new_query_values); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1869
  def relative?; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1774
  def request_uri; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1786
  def request_uri=(new_request_uri); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2085
  def route_from(uri); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2150
  def route_to(uri); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#890
  def scheme; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#917
  def scheme=(new_scheme); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1467
  def site; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1506
  def site=(new_site); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1207
  def tld; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1215
  def tld=(new_tld); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2367
  def to_hash; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2341
  def to_s; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2341
  def to_str; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#941
  def user; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#970
  def user=(new_user); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1052
  def userinfo; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#1091
  def userinfo=(new_userinfo); end

  protected

  # source://addressable/2.8.6/lib/addressable/uri.rb#2561
  def force_utf8_encoding_if_needed(str); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2552
  def remove_composite_values; end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2519
  def replace_self(uri); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2542
  def split_path(path); end

  # source://addressable/2.8.6/lib/addressable/uri.rb#2476
  def validate; end

  private

  # source://addressable/2.8.6/lib/addressable/uri.rb#2573
  def reset_ivs; end

  class << self
    # source://addressable/2.8.6/lib/addressable/uri.rb#292
    def convert_path(path); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#616
    def encode(uri, return_type = T.unsafe(nil)); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#403
    def encode_component(component, character_class = T.unsafe(nil), upcase_encoded = T.unsafe(nil)); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#616
    def escape(uri, return_type = T.unsafe(nil)); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#403
    def escape_component(component, character_class = T.unsafe(nil), upcase_encoded = T.unsafe(nil)); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#740
    def form_encode(form_values, sort = T.unsafe(nil)); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#793
    def form_unencode(encoded_value); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#191
    def heuristic_parse(uri, hints = T.unsafe(nil)); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#1369
    def ip_based_schemes; end

    # source://addressable/2.8.6/lib/addressable/uri.rb#343
    def join(*uris); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#552
    def normalize_component(component, character_class = T.unsafe(nil), leave_encoded = T.unsafe(nil)); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#2440
    def normalize_path(path); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#671
    def normalized_encode(uri, return_type = T.unsafe(nil)); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#114
    def parse(uri); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#1376
    def port_mapping; end

    # source://addressable/2.8.6/lib/addressable/uri.rb#472
    def unencode(uri, return_type = T.unsafe(nil), leave_encoded = T.unsafe(nil)); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#472
    def unencode_component(uri, return_type = T.unsafe(nil), leave_encoded = T.unsafe(nil)); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#472
    def unescape(uri, return_type = T.unsafe(nil), leave_encoded = T.unsafe(nil)); end

    # source://addressable/2.8.6/lib/addressable/uri.rb#472
    def unescape_component(uri, return_type = T.unsafe(nil), leave_encoded = T.unsafe(nil)); end
  end
end

# source://gibbler//lib/gibbler/mixins.rb#17
class Array
  include ::Enumerable
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::Array
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#10
class Class < ::Module; end

# source://gibbler//lib/gibbler/mixins.rb#15
class Date
  include ::Comparable
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::String
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#19
class DateTime < ::Date
  include ::Gibbler::DateTime
end

# source://gibbler//lib/gibbler/mixins.rb#9
class FalseClass
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::String
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#21
class File < ::IO
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::File
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#14
class Float < ::Numeric
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::String
  extend ::Attic
end

# source://gibbler//lib/gibbler.rb#4
GIBBLER_LIB_HOME = T.let(T.unsafe(nil), String)

# source://gibbler//lib/gibbler/mixins.rb#31
class Gem::Platform
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::Complex
  extend ::Attic
end

# = Gibbler
#
# "Hola, Tanneritos"
#
# source://gibbler//lib/gibbler.rb#15
class Gibbler < ::String
  include ::Gibbler::Digest::InstanceMethods

  # Creates a digest from the given +input+. See Gibbler.digest.
  #
  # If only one argument is given and it's a digest, this will
  # simply create an instance of that digest. In other words,
  # it won't calculate a new digest based on that input.
  #
  # @return [Gibbler] a new instance of Gibbler
  #
  # source://gibbler//lib/gibbler.rb#218
  def initialize(*input); end

  # source://gibbler//lib/gibbler.rb#230
  def digest(*input); end

  # source://gibbler//lib/gibbler.rb#226
  def digest_type; end

  # Modify the digest type for this instance. See Gibbler.digest_type
  #
  # source://gibbler//lib/gibbler.rb#211
  def digest_type=(_arg0); end

  # Returns the value of attribute input.
  #
  # source://gibbler//lib/gibbler.rb#212
  def input; end

  class << self
    # Set to true for debug output (including all digest inputs)
    #
    # source://gibbler//lib/gibbler.rb#253
    def debug; end

    # Set to true for debug output (including all digest inputs)
    #
    # source://gibbler//lib/gibbler.rb#253
    def debug=(_arg0); end

    # Returns the current debug status (true or false)
    #
    # @return [Boolean]
    #
    # source://gibbler//lib/gibbler.rb#255
    def debug?; end

    # Returns the value of attribute default_base.
    #
    # source://gibbler//lib/gibbler.rb#21
    def default_base; end

    # Sets the attribute default_base
    #
    # @param value the value to set the attribute default_base to.
    #
    # source://gibbler//lib/gibbler.rb#21
    def default_base=(_arg0); end

    # The delimiter to use when joining Array values before creating a
    # new digest hash. The default is ":".
    #
    # source://gibbler//lib/gibbler.rb#251
    def delimiter; end

    # The delimiter to use when joining Array values before creating a
    # new digest hash. The default is ":".
    #
    # source://gibbler//lib/gibbler.rb#251
    def delimiter=(_arg0); end

    # Sends +input+ to Digest::SHA1.hexdigest. If another digest class
    # has been specified, that class will be used instead.
    # If Gibbler.secret is set, +str+ will be prepended with the
    # value.
    #
    # If +input+ is an Array, it will be flattened and joined.
    #
    # See: digest_type
    #
    # source://gibbler//lib/gibbler.rb#266
    def digest(input, digest_type = T.unsafe(nil)); end

    # Specify a different digest class. The default is +Digest::SHA1+. You
    # could try +Digest::SHA256+ by doing this:
    #
    #     Object.digest_type = Digest::SHA256
    #
    # source://gibbler//lib/gibbler.rb#248
    def digest_type; end

    # Specify a different digest class. The default is +Digest::SHA1+. You
    # could try +Digest::SHA256+ by doing this:
    #
    #     Object.digest_type = Digest::SHA256
    #
    # source://gibbler//lib/gibbler.rb#248
    def digest_type=(_arg0); end

    # source://gibbler//lib/gibbler.rb#276
    def gibbler_debug(*args); end

    # Raises an exception. The correct usage is to include a Gibbler::Object:
    # * Gibbler::Complex
    # * Gibbler::String
    # * Gibbler::Object
    # * etc ...
    #
    # source://gibbler//lib/gibbler.rb#286
    def included(obj); end

    # Returns the value of attribute secret.
    #
    # source://gibbler//lib/gibbler.rb#21
    def secret; end

    # Sets the attribute secret
    #
    # @param value the value to set the attribute secret to.
    #
    # source://gibbler//lib/gibbler.rb#21
    def secret=(_arg0); end
  end
end

# Creates a digest based on:
# * parse each element into an Array of digests like: `CLASS:INDEX:VALUE.__gibbler`
#   * The gibbler method is called on each element so if it is a Hash or Array etc it
#     will be parsed recursively according to the gibbler method for that class type.
# * Digest the Array of digests
# * Return the digest for `class:length:value` where:
#   * "class" is equal to the current object class (e.g. Array).
#   * "length" is the size of the Array of digests (which should equal
#     the number of elements in the original Array object).
#   * "value" is the Array of digests joined with a colon (":").
#
# This method can be used by any class with an `each` method.
#
#     class MyNamedArray
#       include Gibbler::Array
#     end
#
# source://gibbler//lib/gibbler.rb#466
module Gibbler::Array
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#475
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#469
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# Creates a digest based on:
# * An Array of instance variable names or method names and values in the format: `CLASS:LENGTH:VALUE`
#   * The gibbler method is called on each element so if it is a Hash or Array etc it
#     will be parsed recursively according to the gibbler method for that class type.
# * Digest the Array of digests
# * Return the digest for `class:length:value` where:
#   * "class" is equal to the current object class (e.g. FullHouse).
#   * "length" is the size of the Array of digests (which should equal
#     the number of instance variables in the object).
#   * "value" is the Array of digests joined with a colon (":").
#
# This method can be used by any class which stores values in instance variables.
#
#     class Episodes
#       include Gibbler::Complex
#       attr_accessor :season, :year, :cast
#     end
#
# source://gibbler//lib/gibbler.rb#309
module Gibbler::Complex
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#345
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://gibbler//lib/gibbler.rb#363
  def __gibbler_revert!; end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  # source://gibbler//lib/gibbler.rb#334
  def gibbler_fields; end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#312
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# Creates a digest based on: `CLASS:LENGTH:DATETIME`.
# Dates are calculated based on the equivalent datetime in UTC.
# e.g.
#
#     DateTime.parse('2009-08-25T17:00:40+00:00')  => ad64c769
#     DateTime.parse('2009-08-25T13:00:40-04:00')  => ad64c769
#
# To use use method in other classes simply:
#
#     class ClassLikeTime
#       include Gibbler::Time
#     end
#
# source://gibbler//lib/gibbler.rb#537
module Gibbler::DateTime
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#546
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#540
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# = Gibbler::Digest
#
# A tiny subclass of String which adds a
# few digest related convenience methods.
#
# source://gibbler//lib/gibbler.rb#34
class Gibbler::Digest < ::String
  include ::Gibbler::Digest::InstanceMethods
end

# source://gibbler//lib/gibbler.rb#36
module Gibbler::Digest::InstanceMethods
  # Returns true when +ali+ matches +self+
  #
  #    "kimmy".gibbler == "c8027100ecc54945ab15ddac529230e38b1ba6a1"  # => true
  #    "kimmy".gibbler == "c8027100"                                  # => false
  #
  # source://gibbler//lib/gibbler.rb#101
  def ==(ali); end

  # Returns true when +g+ matches one of: +self+, +short+, +shorter+, +tiny+
  #
  #    "kimmy".gibbler === "c8027100ecc54945ab15ddac529230e38b1ba6a1" # => true
  #    "kimmy".gibbler === "c8027100"                                 # => true
  #    "kimmy".gibbler === "c80271"                                   # => true
  #    "kimmy".gibbler === "c802"                                     # => true
  #
  # source://gibbler//lib/gibbler.rb#113
  def ===(g); end

  # source://gibbler//lib/gibbler.rb#48
  def base(base = T.unsafe(nil)); end

  # source://gibbler//lib/gibbler.rb#54
  def base36; end

  # Returns the first 8 characters of itself (the digest).
  #
  # e.g.
  #
  #     "kimmy".gibbler         # => c8027100ecc54945ab15ddac529230e38b1ba6a1
  #     "kimmy".gibbler.short   # => c8027100
  #
  # source://gibbler//lib/gibbler.rb#70
  def short; end

  # Shorten the digest to the given (optional) length.
  #
  # source://gibbler//lib/gibbler.rb#59
  def shorten(len = T.unsafe(nil)); end

  # Returns the first 6 characters of itself (the digest).
  #
  # e.g.
  #
  #     "kimmy".gibbler         # => c8027100ecc54945ab15ddac529230e38b1ba6a1
  #     "kimmy".gibbler.shorter # => c80271
  #
  # source://gibbler//lib/gibbler.rb#81
  def shorter; end

  # Returns the first 4 characters of itself (the digest).
  #
  # e.g.
  #
  #     "kimmy".gibbler         # => c8027100ecc54945ab15ddac529230e38b1ba6a1
  #     "kimmy".gibbler.tiny    # => c802
  #
  # source://gibbler//lib/gibbler.rb#92
  def tiny; end

  # Return an integer assuming base is Gibbler.default_base.
  #
  # source://gibbler//lib/gibbler.rb#38
  def to_i(base = T.unsafe(nil)); end

  # Returns a string. Takes an optional base.
  #
  # source://gibbler//lib/gibbler.rb#44
  def to_s(base = T.unsafe(nil)); end
end

# source://gibbler//lib/gibbler.rb#24
class Gibbler::Error < ::RuntimeError
  # @return [Error] a new instance of Error
  #
  # source://gibbler//lib/gibbler.rb#25
  def initialize(obj); end
end

# Creates a digest based on: `CLASS:PATHLENGTH:PATH`
# where PATHLENGTH is the length of the PATH string. PATH is
# not modified in any way (it is not converted to an absolute
# path).
#
# NOTE: You may expect this method to include other information
# like the file contents and modified date (etc...). The reason
# we do not is because Gibbler is concerned only about Ruby and
# not the outside world. There are many complexities in parsing
# file data and attributes which would make it difficult to run
# across platforms and Ruby versions / engines. If you want to
#
# e.g.
#
#    File.new('.')        # => c8bc8b3a
#    File.new('/tmp')     # => 3af85a19
#    File.new('/tmp/')    # => 92cbcb7d
#
# source://gibbler//lib/gibbler.rb#635
module Gibbler::File
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#644
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#638
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# Creates a digest based on:
# * parse each key, value pair into an Array containing keys: `CLASS:KEY:VALUE.__gibbler`
#   * The gibbler method is called on each element so if it is a Hash or Array etc it
#     will be parsed recursively according to the gibbler method for that class type.
# * Digest the Array of digests
# * Return the digest for `class:length:value` where:
#   * "class" is equal to the current object class (e.g. Hash).
#   * "length" is the size of the Array of digests (which should equal
#     the number of keys in the original Hash object).
#   * "value" is the Array of digests joined with a colon (":").
#
# This method can be used by any class with a `keys` method.
#
#     class MyOrderedHash
#       include Gibbler::Hash
#     end
#
# source://gibbler//lib/gibbler.rb#422
module Gibbler::Hash
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#431
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#425
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# Creates a digest based on: `CLASS:\0`
#
# e.g.
#
#     nil.gibbler      # => 06fdf26b
#
# source://gibbler//lib/gibbler.rb#600
module Gibbler::Nil
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#609
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#603
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# source://gibbler//lib/gibbler.rb#122
module Gibbler::Object
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self based on:
  # * Object#class
  # * Length of Object#name || 0
  # * Object#name || ''
  #
  # e.g. Digest::SHA1.hexdigest "Class:6:Object" #=>
  #
  # <b>This is a default method appropriate for only the most
  # basic objects like Class and Module.</b>
  #
  # source://gibbler//lib/gibbler.rb#184
  def __gibbler(digest_type = T.unsafe(nil)); end

  # A simple override on Object#freeze to create a digest
  # before the object is frozen. Once the object is frozen
  # `obj.gibbler` will return the cached value with
  # out calculation.
  #
  # source://gibbler//lib/gibbler.rb#197
  def freeze; end

  # Has this object been modified?
  #
  # This method compares the return value from digest with the
  # previous value returned by gibbler (the value is stored in
  # the attic as `gibbler_cache`).
  # See Attic[http://github.com/delano/attic]
  #
  # @return [Boolean]
  #
  # source://gibbler//lib/gibbler.rb#162
  def gibbled?; end

  # Calculates a digest for the current object instance.
  # Objects that are a kind of Hash or Array are processed
  # recursively. The length of the returned String depends
  # on the digest type. Also stores the value in the attic.
  #
  #     obj.gibbler          # => a5b1191a
  #     obj.gibbler_cache    # => a5b1191a
  #
  # Calling gibbler_cache returns the most recent digest
  # without calculation.
  #
  # If the object is frozen, this will return the value of
  # `gibbler_cache`.
  #
  # source://gibbler//lib/gibbler.rb#148
  def gibbler(digest_type = T.unsafe(nil)); end

  # source://gibbler//lib/gibbler.rb#169
  def gibbler_debug(*args); end

  # source://gibbler//lib/gibbler.rb#131
  def gibbler_fields; end

  class << self
    # source://gibbler//lib/gibbler.rb#129
    def gibbler_fields; end

    # @private
    #
    # source://gibbler//lib/gibbler.rb#124
    def included(obj); end
  end
end

# Creates a digest based on: `CLASS:EXCLUDE?:FIRST:LAST`
# where EXCLUDE? is a boolean value whether the Range excludes
# the last value (i.e. 1...100) and FIRST and LAST are the values
# returned by Range#first and Range#last.
# e.g.
#
#     (1..100)   =>  Range:false:1:100  =>  54506352
#     (1...100)  =>  Range:true:1:100   =>  f0cad8cc
#
# To use use method in other classes simply:
#
#     class ClassLikeRange
#       include Gibbler::Range
#     end
#
# source://gibbler//lib/gibbler.rb#571
module Gibbler::Range
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#580
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#574
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# Creates a digest based on: `CLASS:LENGTH:VALUE`.
# This method can be used for any class where the `to_s`
# method returns an appropriate unique value for this instance.
# It's used by default for Symbol, Class, Integer.
# e.g.
#
#     "str" => String:3:str => 509a839ca1744c72e37759e7684ff0daa3b61427
#     :sym  => Symbol:3:sym => f3b7b3ca9529002c6826b1ef609d3583c356c8c8
#
# To use use method in other classes simply:
#
#     class MyStringLikeClass
#       include Gibbler::String
#     end
#
# source://gibbler//lib/gibbler.rb#387
module Gibbler::String
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#396
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#390
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# Creates a digest based on: `CLASS:LENGTH:TIME`.
# Times are calculated based on the equivalent time in UTC.
# e.g.
#
#     Time.parse('2009-08-25 16:43:53 UTC')     => 73b4635f
#     Time.parse('2009-08-25 12:43:53 -04:00')  => 73b4635f
#
# To use use method in other classes simply:
#
#     class ClassLikeTime
#       include Gibbler::Time
#     end
#
# source://gibbler//lib/gibbler.rb#506
module Gibbler::Time
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
  include ::Attic::InstanceMethods

  mixes_in_class_methods ::Attic

  # Creates a digest for the current state of self.
  #
  # source://gibbler//lib/gibbler.rb#515
  def __gibbler(digest_type = T.unsafe(nil)); end

  # source://attic/1.0.1/lib/attic.rb#191
  def gibbler_cache; end

  # source://attic/1.0.1/lib/attic.rb#197
  def gibbler_cache=(val); end

  class << self
    # @private
    #
    # source://gibbler//lib/gibbler.rb#509
    def included(obj); end

    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# source://gibbler//lib/gibbler/mixins.rb#16
class Hash
  include ::Enumerable
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::Hash
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#7
class Integer < ::Numeric
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::String
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#23
class MatchData
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::String
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#11
class Module
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#4
class NilClass
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::Nil
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#24
class OpenStruct
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#12
class Proc
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#20
class Range
  include ::Enumerable
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::Range
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#13
class Regexp
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::String
  extend ::Attic
end

# source://gibbler//lib/gibbler.rb#655
class String
  include ::Comparable
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::String
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#6
class Symbol
  include ::Comparable
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::String
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#22
class TempFile
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::File
  extend ::Attic

  # source://attic/1.0.1/lib/attic.rb#156
  def all_instance_variables; end

  # source://attic/1.0.1/lib/attic.rb#151
  def instance_variables; end

  class << self
    # source://attic/1.0.1/lib/attic.rb#144
    def inherited(klass); end
  end
end

# source://gibbler//lib/gibbler/mixins.rb#18
class Time
  include ::Comparable
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::Time
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#8
class TrueClass
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::String
  extend ::Attic
end

# source://gibbler//lib/gibbler/mixins.rb#28
class URI::Generic
  include ::URI::RFC2396_REGEXP
  include ::Gibbler::Object
  include ::Attic::InstanceMethods
  include ::Gibbler::String
  extend ::Attic
end
